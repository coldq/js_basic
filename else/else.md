### 块级元素（哪些是块级元素）

div、p(paragraph)、form、h1,2...、menu、blockquote 、ol(order list)、ul(unorder list)、pre(格式化文本)等都是块级元素。

#### 块级元素：block element 

每个块级元素默认占一行高度，一行内添加一个块级元素后无法一般无法添加其他元素（float浮动后除外）。两个块级元素连续编辑时，会在页面自动换行显示。块级元素一般可嵌套块级元素或行内元素；

块级元素一般作为容器出现，用来组织结构，但并不全是如此。有些块级元素，如<form>只能包含块级元素。其他的块级元素则可以包含 行级元素如<P>.也有一些则既可以包含块级，也可以包含行级元素。

#### 行内元素：inline element 

也叫内联元素、内嵌元素等；行内元素一般都是基于语义级 (semantic) 的基本元素，只能容纳文本或其他内联元素，常见内联元素 “a”。比如 SPAN 元素，IFRAME元素和元素样式的 display : inline 的都是行内元素。例如文字这类元素，各个字母 之间横向排列，到最右端自动折行。

### css选择器优先级
内联 > id选择器 > 类选择器 > 标签选择器

### css布局中，什么是BFC
- [前端精选文摘：BFC 神奇背后的原理](http://www.cnblogs.com/lhb25/p/inside-block-formatting-ontext.html)
- [块级可视化上下文](http://www.mamicode.com/info-detail-77362.html)
BFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素。反之也如此。

一个BFC是一个HTML盒子并且至少满足下列条件中的任何一个：
- float的值不为none
- position的值不为static或者relative
- display的值为 table-cell, table-caption, inline-block, flex, 或者 inline-flex中的其中一个
- overflow的值不为visible

#### 作用：
1. 不和浮动元素重叠
2. 清除内部浮动
3. 防止垂直 margin 重叠

#### 对触发BFC的方法，能用在自适应布局中的方法如下

- overflow（hidden/auto）,缺点：
  1. overflow:hidden当内容过多时，带有剪裁功能；
  2. overflow:auto当内容过多时，会出现滚动条

- display:inline-block, 缺点：只适用于IE6、7

- display:table-cell, 缺点：只适用于IE8+和其他浏览器


### 浏览器打开一个网页：
1. 浏览器通过访问域名查找最近的IP地址，一个例子是如果你想用谷歌浏览器，可以下载一个最新的host版本，当你通过谷歌访问的时候浏览器会首先查找本地的IP地址，达到可以使用谷歌的目的；
2. 浏览器给web服务器发送一个http请求；
3. 服务器给浏览器相应一个永久重定向，比如说我们在地址栏输入baidu，虽然没写完整，但是浏览器会通过永久重定向去加上`http://www.baidu.com`,仍然会让用户访问的到，服务器重定向会防止搜索引擎干预，搜索引擎收到301永久重定向就会把`http://baidu.com`和`http://www.baidu.com`看成一个网站；
4. 服务器处理请求，如果请求出错就会出现常见的404状态码的情况；
5. 服务器返回http响应；
6. 浏览器开始显示HTML；
7. 浏览器发送一个获取请求，找到嵌入在HTML中的对象，是图片还是文字，是样式表还是行为等等；8、服务器发送异步（AJAX）请求。

### 树的遍历 先序，中序，后序

- 前序遍历：根节点->左子树->右子树
- 中序遍历：左子树->根节点->右子树
- 后序遍历：左子树->右子树->根节点

如下树：
```
       a
     /   \
    b     c
  /   \
d      f
 \    /
  e  g
```

- 先序： abdefgc 
- 中序： debgfac
- 后序： edgfbca

后序的最后节点肯定是根节点，和中序配合可以分出左右子树。

else： 二叉树的深度：从root到节点；高度：从叶子到节点

### w3c 制定的 javascript 标准事件模型

事件捕获->事件处理->事件冒泡

### 进程

进程间的基本关系为同步与互斥

产生死锁的必要条件：互斥条件，请求与保持条件，不剥夺条件以及循环等待条件

动态性：进程的实质是程序在多道程序系统中的一次执行过程，进程是动态产生，动态消亡的。

并发性：任何进程都可以同其他进程一起并发执行

独立性：进程是一个能独立运行的基本单位，同时也是系统分配资源和调度的独立单位；

异步性：由于进程间的相互制约，使进程具有执行的间断性，即进程按各自独立的、不可预知的速度向前推进

进程主要组成部分：
1. 程序。作用：描述进程要完成的功能。
2. 数据。作用：程序在执行时所需要的数据和工作区。
3. PCB。作用：包含进程的描述信息和控制信息。它是进程存在的唯一标志。 

### JavaScript 数据类型

字符串、数字、布尔、数组、对象、Null、Undefined

### 假设一个主机的ip地址为192.168.8.123，而子网掩码为255.255.255.248，

步骤一：首先将网络的IP地址和子网掩码都转换成32位二进制字符。　　
步骤二：将转换后的二进制的IP地址和子网掩码进行“逻辑与”运算，得到新的32位二进制字符。
步骤三：把得到的新的32位二进制字符转换成十进制，就是主机的网络号了。
　　
本例中 255 各位都是1，因此ip前三个都不变；
248： 1111 1000  
123： 0111 1011  与运算后： 0111 1000
那么该主机的网络号是192.168.8.120

### 路由汇聚

1. 各子网地址的网段以二进制写出。
2. 比较，从第1位比特开始进行比较，将从开始不相同的比特到末尾位填充为0。由此得到的地址为汇总后的网段的网络地址，其网络位为连续的相同的比特的位数。

假设下面有4个网络:172.18.129.0/24； 172.18.130.0/24 ；172.18.132.0/24 ；172.18.133.0/24
如果这四个进行路由汇聚,能覆盖这四个网络的汇总地址是:
172.18.128.0/21
算法为：129的二进制代码是10000001
130的二进制代码是10000010
132的二进制代码是10000100
133的二进制代码是10000101
这四个数的前五位相同都是10000，所以加上前面的172.18这两部分相同的位数，网络号就是8+8+5=21。而10000000的十进制数是128，所以，路由汇聚的Ip地址就是172.18.128.0。所以最终答案就是172.18.128.0/21。


###计算机网络通常由三个部分组成，
它们是资源子网、通信子网和通信协议。

1. 所谓通信子网就是计算机网络中负责数据通信的部分；

2. 资源子网是计算机网络中面向用户的部分，负责全网络面向应用的数据处理工作；

3. 而通信双方必须共同遵守的规则和约定就称为通信协议，它的存在与否是计算机网络与一般计算机互连系统的根本区别。

### AMD CMD

[AMD](https://github.com/amdjs/amdjs-api/wiki/AMD) 是 RequireJS 在推广过程中对模块定义的规范化产出。[CMD](https://github.com/seajs/seajs/issues/242)是 SeaJS 在推广过程中对模块定义的规范化产出。类似的还有 CommonJS Modules/2.0 规范，是 BravoJS 在推广过程中对模块定义的规范化产出。还有不少⋯⋯

这些规范的目的都是为了 JavaScript 的模块化开发，特别是在浏览器端的。目前这些规范的实现都能达成浏览器端模块化开发的目的。

区别：
1. 对于依赖的模块，AMD 是提前执行，CMD 是延迟执行。不过 RequireJS 从 2.0 开始，也改成可以延迟执行（根据写法不同，处理方式不同）。CMD 推崇 as lazy as possible.
2. CMD 推崇依赖就近，AMD 推崇依赖前置。看代码：

CMD
```
define(function(require, exports, module) { 
    var a = require('./a')  
    a.doSomething()  
    // 此处略去 100 行  
    var b = require('./b') // 依赖可以就近书写  
     b.doSomething()   
     // ...
     })
```
AMD 默认推荐的是
```
define(['./a', './b'], function(a, b) {  // 依赖必须一开始就写好  
    a.doSomething()   
    // 此处略去 100 行  
    b.doSomething()    
    ...
}) 
```
虽然 AMD 也支持 CMD 的写法，同时还支持将 require 作为依赖项传递，但 RequireJS 的作者默认是最喜欢上面的写法，也是官方文档里默认的模块定义写法。
3. AMD 的 API 默认是一个当多个用，CMD 的 API 严格区分，推崇职责单一。比如 AMD 里，require 分全局 require 和局部 require，都叫 require。CMD 里，没有全局 require，而是根据模块系统的完备性，提供 seajs.use 来实现模块系统的加载启动。CMD 里，每个 API 都简单纯粹。
4. 还有一些细节差异，具体看这个规范的定义就好，就不多说了。另外，SeaJS 和 RequireJS 的差异，可以参考:https://github.com/seajs/seajs/issues/277

### 面向对象：
抽象，继承，封装，多态性

### 闭包的应用

1. 词法作用域 ： 创建内部变量不能被随意改变，同时又可以用指定的函数接口来操作；
2. 把代码封装成闭包形式，时机成熟时再使用，比如实现柯里化和反柯里化
3. 闭包可以给对象设置私有属性并利用特权(Privileged)方法访问私有属性。

### 柯里化：提高函数复用，绑定固定参数
js柯里化是逐步传参，逐步缩小函数的适用范围，逐步求解的过程。
[JavaScript的函数currying 柯里化](http://www.haorooms.com/post/js_currying)

反柯里化是 函数的借用，是函数能够接受处理其他对象，通过借用泛化、扩大了函数的使用范围。

### 变量对象、活动对象
变量对象：包含函数中的所有函数和变量

变量对象有多个，其中有活动对象，活动对象就是作用域链上正在被执行和引用的变量对象。

### react-router原理

[参考](https://github.com/joeyguo/blog/issues/2)
可以将 react-router 的整个包装闭环总结为
- 回调函数：含有能够更新 react UI 的 react setState 方法。
- 注册回调：在 Router componentWillMount 中使用 history.listen 注册的回调函数，最终放在 history 模块的 回调函数数组 changeListeners 中。
- 触发回调：Link 点击触发 history 中回调函数数组 changeListeners 的执行，从而触发原来 listen 中的 setState 方法，更新了页面

### 数据库设计三大范式

1. 第一范式(确保每列保持原子性)

2. 第二范式(确保表中的每列都和主键相关)

3. 第三范式(确保每列都和主键列直接相关,而不是间接相关)

### 在 javascript 中，用于阻止默认事件的默认操作的方法是

w3c的方法是e.preventDefault()，IE则是使用e.returnValue = false;

### 跨域解决：
利用HTML5 postMessage
利用document.domain+iframe的设置
通过服务端niginx配置跨域
利用iframe+location.hash
windows,name实现跨域数据传输

### Linux创建文件的指令
1. touch ： 创建空白文件或修改文件时间

2. cat主要有三大功能：
  - 一次显示整个文件。
  - 从键盘创建一个文件。只能创建新文件,不能编辑已有文件.
  - 将几个文件合并为一个文件

3. vi/vim可用来创建文件编辑文件并保存

4. > 是定向输出到文件，如果文件不存在，就创建文件；如果文件存在，就将其清空；

### 数据链路层主要功能包括：

差错控制
提供对物理层的控制
流量控制
MAC寻址

### 网络层

路径选择、路由及逻辑寻址

### css3 有哪些新特性
第 1 选择器、第 2 RGBA和透明度、第 3 多栏布局、第 4 多背景图、第 5 Word Wrap、第 6 文字阴影、
第 7 @font-face属性、第 8 圆角(边框半径)、第 9 边框图片、第 10 盒阴影、第 11 盒子大小、第 12 媒体查询、第 13 语音

### for in
1. js中for in 可以遍历对象或数组的显性属性，也就是说我们自己定义的属性是可以遍历的，那些原型上默认已有的属性，例如：Object.prototype.toString、Object.prototype.hasOwnProperty 是遍历不出来的。

2. for in循环出的值不一定是按顺序的。

3. 在原型上加扩展方法，会被for in 出来。

### 全双工 半双工

全双工指在发送数据的同时也能够接收数据，两者同步进行。目前的网卡一般都支持全双工。
 
半双工:数据可以在一个信号载体的的两个方向上传输，但是不能同时传输。